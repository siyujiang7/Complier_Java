/**
 * Created by siyujiang on 2/9/17.
 */

//import com.sun.javafx.fxml.expression.Expression;

import java.lang.*;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

class ExprEval {
    Lexer lex;
    Token1 nextToken;
    Stack<Token1> t_stack;
    int inPair;
    double value;
    public ExprEval(String expr, double value) {
        lex = new Lexer(expr);
        nextToken = lex.lex();
        t_stack = new Stack<Token1>();
        inPair = 0;
        this.value = value;
    }

    public boolean verifyParen() {
        if (lex.tokens.size() == 1 && lex.tokens.get(0).type != TokenType.LPAREN && lex.tokens.get(0).type != TokenType.RPAREN)
            return true;
        for (int i = 0; i < lex.tokens.size(); i++) {
            if (lex.tokens.get(i).data.equals(")")) {
                if (t_stack.isEmpty())
                    return false;
                if(i + 1 < lex.tokens.size()){
                    if (lex.tokens.get(i + 1).data.equals("("))
                        return false;
                }
                String s;
                while (!(s = t_stack.pop().data).equals("(")) {
                    if (s.equals("{") || s.equals("[") || t_stack.isEmpty())
                        return false;
                }
            } else if (lex.tokens.get(i).data.equals("}")) {
                if (t_stack.isEmpty())
                    return false;
                String s;
                while (!(s = t_stack.pop().data).equals("{")) {
                    if (s.equals("(") || s.equals("[") || t_stack.isEmpty())
                        return false;
                }
            } else if (lex.tokens.get(i).data.equals("]")) {
                if (t_stack.isEmpty())
                    return false;
                String s;
                while (!(s = t_stack.pop().data).equals("[")) {
                    if (s.equals("(") || s.equals("{") || t_stack.isEmpty())
                        return false;
                }
            } else {
                Token1 temp = new Token1(lex.tokens.get(i).type, lex.tokens.get(i).data);
                t_stack.push(temp);
            }
        }
        while (!t_stack.isEmpty()) {
            String s = t_stack.pop().data;
            if (s.equals("(") || s.equals("{") || s.equals("["))
                return false;
        }
        return true;
    }

    void expr() {
        //Parse the first term
        //nextToken = lex.lex();
        term();
        // As long as the next Token1 is + or -, call
        // lex to get the next Token1 and parse the
        // next term
        if (nextToken.type == TokenType.COMMA && inPair == 0)
            error();
        if (nextToken.type == TokenType.POWER) {
            nextToken = lex.lex();
            if (nextToken.type == TokenType.INT) {
                factor();
            } else if (nextToken.type == TokenType.LPAREN) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
                else
                    error();
            } else
                error();
        }
        while (nextToken.type == TokenType.ADD ||
                nextToken.type == TokenType.SUB) {
            nextToken = lex.lex();
            term();
        }
        //System.out.println("expr");
    }

    // Function term
    // Parses strings in the language generated by the rule:
    // <term> -> <factor> {(* | /) <factor>)
    void term() {
        // Parse the first factor
        factor();
        // As long as the next Token1 is * or /,
        // next Token1 and parse the next factor
        while (nextToken.type == TokenType.MULT ||
                nextToken.type == TokenType.DIV) {
            nextToken = lex.lex();
            factor();
        }
        //System.out.print("term ");
    }

    void pair() {
        if (nextToken.type == TokenType.LPAREN) {
            nextToken = lex.lex();
            inPair++;
            expr();
            if (nextToken.type == TokenType.COMMA) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
                else
                    error();
            } else
                error();
        } else
            error();
        inPair--;
        //System.out.println("pair");
    }

    // Function factor
    // Parses strings in the language
    // generated by the rule:
    //   <factor> -> id  |  (<expr>)
    void factor() {
        // Determine which RHS (Right-hand side)
        if (nextToken.type == TokenType.ID ||
                nextToken.type == TokenType.INT ||
                nextToken.type == TokenType.DOUBLE) {
            // For the RHS id, just call lex
            Token1 t = nextToken;
            nextToken = lex.lex();
            if (nextToken.type != TokenType.ERROR) {
                if (nextToken.type != TokenType.ADD
                        && nextToken.type != TokenType.SUB
                        && nextToken.type != TokenType.MULT
                        && nextToken.type != TokenType.DIV
                        && nextToken.type != TokenType.POWER
                        && nextToken.type != TokenType.RPAREN) {
                    System.out.println("bad format");
                    System.exit(1);
            }
            }
        } else if (nextToken.type == TokenType.COMMA && inPair > 0)
            nextToken = lex.lex();
        else if (nextToken.type == TokenType.LPAREN) {
            nextToken = lex.lex();
            expr();
            if (nextToken.type == TokenType.RPAREN)
                nextToken = lex.lex();
            else
                error();
        } else if (nextToken.type == TokenType.SIN) {
            nextToken = lex.lex();
            if (nextToken.type == TokenType.LPAREN) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
            } else
                error();
        } else if (nextToken.type == TokenType.COS) {
            nextToken = lex.lex();
            if (nextToken.type == TokenType.LPAREN) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
            } else
                error();
        } else if (nextToken.type == TokenType.TAN) {
            nextToken = lex.lex();
            if (nextToken.type == TokenType.LPAREN) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
            } else
                error();
        } else if (nextToken.type == TokenType.ATAN) {
            nextToken = lex.lex();
            if (nextToken.type == TokenType.LPAREN) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
            } else
                error();
        } else if (nextToken.type == TokenType.ATAN2) {
            nextToken = lex.lex();
            pair();
        } else if (nextToken.type == TokenType.LN) {
            nextToken = lex.lex();
            if (nextToken.type == TokenType.LPAREN) {
                nextToken = lex.lex();
                expr();
                if (nextToken.type == TokenType.RPAREN)
                    nextToken = lex.lex();
            } else
                error();
        } else error(); /* Neither RHS matches */
        //System.out.print("factor ");
    }

    void error() {
        System.out.println("Poor Format!");
        System.exit(1);
    }

    public static void main(String args[]) throws Exception {
        if (args.length < 2) {
            System.out.println("Usage: java expression xval");
            System.exit(1);
        }
        ExprEval e = new ExprEval(args[0],Double.parseDouble(args[1]));
        //System.out.println(e.value);
        double val = e.evaluate();
        //System.out.println(args[0]);
        System.out.println("y=" + val);
    }


    public double evaluate() throws Exception {
        if (!verifyParen()) {
            System.out.println("Wrong Format! Check the number of symbols!");
            System.exit(1);
        }
        expr();
        LinkedList<Token1> q_token = new LinkedList<>();
        for (int i = 0; i < lex.tokens.size(); i++) {
            Token1 t = new Token1(lex.tokens.get(i).type, lex.tokens.get(i).data);
            if (t.type == TokenType.INT || t.type == TokenType.DOUBLE)
                q_token.add(t);
            else if (t.type == TokenType.ID){
                Token1 temp = new Token1(t.type,Double.toString(value));
                q_token.add(temp);
            }
            else if (t.type == TokenType.ADD || t.type == TokenType.SUB) {
                while (!t_stack.isEmpty()) {
                    if (t_stack.peek().type != TokenType.LPAREN) {
                        q_token.add(t_stack.pop());
                    }
                    else
                        break;
                }
                t_stack.push(t);
            } else if (t.type == TokenType.MULT || t.type == TokenType.DIV) {
                while (!t_stack.isEmpty()) {
                    if (t_stack.peek().type != TokenType.ADD
                            && t_stack.peek().type != TokenType.SUB
                            && t_stack.peek().type != TokenType.LPAREN) {
                        q_token.add(t_stack.pop());
                    }
                    else break;;
                }
                t_stack.push(t);
            } else if (t.type == TokenType.POWER) {
                while (!t_stack.isEmpty()) {
                    if (t_stack.peek().type != TokenType.ADD
                            && t_stack.peek().type != TokenType.SUB
                            && t_stack.peek().type != TokenType.LPAREN
                            && t_stack.peek().type != TokenType.MULT
                            && t_stack.peek().type != TokenType.DIV
                            && t_stack.peek().type != TokenType.POWER) {
                        q_token.add(t_stack.pop());
                    }
                    else
                        break;
                }
                t_stack.push(t);
            } else if (t.type == TokenType.LPAREN) {
                t_stack.push(t);
            } else if (t.type == TokenType.RPAREN) {
                while (!t_stack.isEmpty()) {
                    if (t_stack.peek().type != TokenType.LPAREN)
                        q_token.add(t_stack.pop());
                    else
                        break;
                }
                t_stack.pop();
            }else if (t.type == TokenType.SIN
                    || t.type == TokenType.COS
                    || t.type == TokenType.ATAN2
                    || t.type == TokenType.ATAN
                    || t.type == TokenType.TAN
                    || t.type == TokenType.LN){
                t_stack.push(t);
            }else if (t.type == TokenType.COMMA){
                while (!t_stack.isEmpty()){
                    if (t_stack.peek().type != TokenType.LPAREN)
                        q_token.add(t_stack.pop());
                    else
                        break;
                }
            }
        }
        while (!t_stack.isEmpty()){
            q_token.add(t_stack.pop());
        }
        Stack<Double> ts = new Stack<Double>();
        int len = q_token.size();
        for (int i = 0; i < len; i++){
            Token1 t = q_token.pollFirst();
            if (t.type == TokenType.ID || t.type == TokenType.INT || t.type == TokenType.DOUBLE){
                ts.push(Double.parseDouble(t.data));
            }
            else if (t.type == TokenType.ADD){
                double a = ts.pop();
                double b = ts.pop();
                double c = a+b;
                ts.push(c);
            }
            else if (t.type == TokenType.SUB){
                double a = ts.pop();
                double b = ts.pop();
                double c = b-a;
                ts.push(c);
            }
            else if (t.type == TokenType.MULT){
                double a = ts.pop();
                double b = ts.pop();
                double c = a*b;
                ts.push(c);
            }
            else if (t.type == TokenType.DIV){
                double a = ts.pop();
                double b = ts.pop();
                double c = b/a;
                ts.push(c);
            }
            else if (t.type == TokenType.SIN){
                double a = ts.pop();
                double c = Math.sin(a);
                ts.push(c);
            }
            else if (t.type == TokenType.COS){
                double a = ts.pop();
                double c = Math.cos(a);
                ts.push(c);
            }
            else if (t.type == TokenType.TAN){
                double a = ts.pop();
                double c = Math.tan(a);
                ts.push(c);
            }
            else if (t.type == TokenType.ATAN){
                double a = ts.pop();
                double c = Math.atan(a);
                ts.push(c);
            }
            else if (t.type == TokenType.LN){
                double a = ts.pop();
                double c = Math.log(a);
                ts.push(c);
            }
            else if (t.type == TokenType.ATAN2){
                double a = ts.pop();
                double b = ts.pop();
                double c = Math.atan2(b,a);
                ts.push(c);
            }
            else if (t.type == TokenType.POWER){
                double a = ts.pop();
                double b = ts.pop();
                double c = Math.pow(b,a);
                ts.push(c);
            }
        }
        return ts.pop();
    }
}


